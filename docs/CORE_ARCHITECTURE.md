# CORE_ARCHITECTURE.md

## 1. 概要

このドキュメントでは、YamlGuardian プロジェクトで使用するアーキテクチャの中核となる概念を定義します。特に、各モジュールの責務を明確にするための 3x3 マトリクス (以下、**責務定義マトリクス**) について詳しく説明します。

## 2. 全体構成

YamlGuardian のアーキテクチャは、以下の 3 つの主要な要素で構成されています。

1.  **アプリケーション層 (Application Layer):**
    *   システムの全体的なユースケースを定義し、外部からのリクエストを処理します。
    *   `Orchestration` モジュール、`Presentation` モジュール、`Validation` モジュールを連携させ、ユースケースを実現します。
    *   **Facade パターン:** 各ユースケースは、`Validation` モジュールなどの複雑なサブシステムを `Facade` パターンを通じて簡潔に利用し、コードの複雑さを軽減します。
2.  **責務定義マトリクス (Responsibility Definition Matrix):**
    *   各モジュールの責務を明確化するための 3x3 マトリクスです。
    *   モジュールの種類、処理の方向性、処理段階という 3 つの軸で構成されています。
    *   詳細は「3. 責務定義マトリクス」を参照してください。
3.  **共通コンポーネント (Common Components):**
    *   システム全体で共有される共通機能を提供します。
    *   ロギング、ユーティリティ関数、例外処理などが含まれます。

## 3. 責務定義マトリクス (Responsibility Definition Matrix)

YamlGuardian では、モジュールの責務を明確にするために、以下の 3 つの軸で構成されるマトリクスを使用します。

*   **目的:**
    *   各モジュールの責務を明確化する。
    *   コードの配置場所を決定する際の指針とする。
    *   チーム全体でアーキテクチャを理解しやすくする。
*   **3x3 の理由:**
    *   YamlGuardian のアーキテクチャでは、機能を最大限に分離し、各モジュールが単一の責務を持つように設計されています。
    *   この目的を達成するために、モジュールの種類、処理の方向性、処理段階という 3 つの軸で細かく分類し、各モジュールの責務を明確に定義します。

### 3.1 モジュールの種類 (Module Type)

各機能に対する具体的な処理は、モジュールの種類によって異なります。

1.  **検証 (Validation):**
    *   `Schema`, `Rule`, `Data` サブモジュールが含まれます。
2.  **プレゼンテーション (Presentation):**
    *   `Input`, `Output` サブモジュールが含まれます。

### 3.2 処理の方向性 (Processing Direction)

各処理は、以下のいずれかの方向性を持つものとして定義します。この方向性は、サブモジュールの命名規則によって識別できます。

1.  **インタラクション向き (Interaction-Facing):**
    *   外部システムやユーザーとのインタラクションを扱う。
    *   サブモジュールは `prepare -> transform -> deliver` という命名規則に従います。
2.  **コア向き (Core-Facing):**
    *   アプリケーションのコアロジックに関連する処理を扱う。
    *   サブモジュールは `input -> logic -> output` という命名規則に従います。

### 3.3 処理段階 (Processing Stage)

YamlGuardian のアーキテクチャでは、処理段階は「インタラクション処理段階」と「コア処理段階」の2つに分かれます。

1.  **インタラクション処理段階 (Interaction Processing Stage):**
    *   **対象モジュール**: Presentation
    *   **段階:**
        1.  **準備 (Prepare):** 外部からのデータを受け取り、システム内部で使用できる形式に変換する。
        2.  **ロジック (Logic):** 受け取ったデータを検証・変換し、後続のモジュールで処理しやすい形式にする。
        3.  **後処理 (Postprocess):** システム内部で処理されたデータを、次のレイヤーが利用できる形式で提供する。

2.  **コア処理段階 (Core Processing Stage):**
    *   **対象モジュール**: Validation
    *   **段階:**
        1.  **抽出 (Extract):** 検証に必要な情報源からデータを取り出す。
        2.  **変換 (Transform):** 取り出した情報を検証ロジックが利用できる形に変換する。
        3.  **配信 (Deliver):** 検証結果や処理後のデータを、必要に応じて外部に提供したり、キャッシュに保存したりする。

## 4. サブモジュールの命名規則

サブモジュールの命名規則は、以下の2パターンで固定します。ただし、この命名規則に合わない場合は、より適切な名前を検討し、その理由を明確にドキュメント化します。

*   **コア向き（ロジック側）の処理:** input -> logic -> output
*   **インタラクション向き（ユーザ側）の処理:** prepare -> transform -> deliver

## 5. その他

*   **共通コンポーネント (Common Components):**
    *   `Commons`: ロギング、ユーティリティ関数などを提供します。
    *   `Infrastructure`: 外部サービス連携などを抽象化します。
*   **設計原則:**
    *   依存性逆転の原則 (Dependency Inversion Principle) を積極的に活用し、柔軟性とテスト容易性を高めます。
    *   共通処理を `Commons` モジュールに集約することで、コードの再利用性を高め、保守性を向上させます。
    *   `Infrastructure` モジュールを通じて、外部サービスやフレームワークへの依存性を低減することで、システムの移植性を高めます。
    *   各モジュールの責務を明確にすることで、単体テストを容易にし、コードの品質を向上させます。
    *   3x3 マトリクスは、あくまで設計の指針であり、状況に応じて柔軟に対応します。

## 6. マトリクスの目的

*   各モジュールの責務を明確化する。
*   コードの配置場所を決定する際の指針とする。
*   チーム全体でアーキテクチャを理解しやすくする。
